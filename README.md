# Запуск проєкту

```bash
python3 -m venv .venv
.venv/bin/pip install -r requirements.txt
.venv/bin/python main.py
```

# Задача про розмін монет: Жадібний алгоритм vs Динамічне програмування

## Алгоритми
- **Жадібний алгоритм**  
  На кожному кроці вибирає найбільший доступний номінал монети, доки не буде зібрано потрібну суму.  
  - Часова складність: **O(n)**, де `n` — кількість номіналів.  
  - Надзвичайно швидкий, навіть для дуже великих сум.  
  - Гарантовано оптимальний лише для *канонічних систем монет* (наприклад, `[50, 25, 10, 5, 2, 1]`).

- **Динамічне програмування (мінімальна кількість монет)**  
  Знаходить справжню мінімальну кількість монет для будь-якої системи.  
  - Часова складність: **O(сума × n)**.  
  - Гарантує оптимальність для будь-яких номіналів.  
  - Набагато повільніше для великих сум і використовує більше памʼяті.

---

## Експерименти

Ми протестували обидва алгоритми з канонічною системою монет `[50, 25, 10, 5, 2, 1]` для різних сум.

| Сума | Результат жадібного | Результат ДП | Час жадібного (мс) | Час ДП (мс) |
| ---: | -------------------- | ------------- | ------------------:| -----------:|
| 1 | `{1: 1}` | `{1: 1}` | 0.0159 | 0.0153 |
| 7 | `{5: 1, 2: 1}` | `{2: 1, 5: 1}` | 0.0054 | 0.0129 |
| 23 | `{10: 2, 2: 1, 1: 1}` | `{1: 1, 2: 1, 10: 2}` | 0.0030 | 0.0153 |
| 99 | `{50: 1, 25: 1, 10: 2, 2: 2}` | `{2: 2, 10: 2, 25: 1, 50: 1}` | 0.0027 | 0.0586 |
| 123 | `{50: 2, 10: 2, 2: 1, 1: 1}` | `{1: 1, 2: 1, 10: 2, 50: 2}` | 0.0029 | 0.0668 |
| 512 | `{50: 10, 10: 1, 2: 1}` | `{2: 1, 10: 1, 50: 10}` | 0.0026 | 0.2931 |
| 1,000 | `{50: 20}` | `{50: 20}` | 0.0030 | 0.5858 |
| 5,000 | `{50: 100}` | `{50: 100}` | 0.0032 | 4.2180 |
| 10,000 | `{50: 200}` | `{50: 200}` | 0.0201 | 9.6580 |
| 50,000 | `{50: 1000}` | `{50: 1000}` | 0.0157 | 45.5480 |
| 100,000 | `{50: 2000}` | `{50: 2000}` | 0.0156 | 74.0980 |
| 200,000 | `{50: 4000}` | `{50: 4000}` | 0.0160 | 148.4670 |

---

## Спостереження
1. Для цієї канонічної системи **обидва алгоритми дають однакову комбінацію монет**, що підтверджує оптимальність жадібного підходу.
2. Жадібний алгоритм завершується за мікросекунди і масштабується за кількістю номіналів (`O(k)`), тому час виконання практично не залежить від суми.
3. Метод ДП гарантує мінімальну кількість монет, але масштабується за цільовою сумою (`O(сума × k)`), досягаючи ~150 мс для 200 000 навіть із шістьма номіналами.
4. Для неканонічних систем жадібний алгоритм може дати неоптимальний результат (наприклад, монети `[1, 3, 4]`, сума `6` → жадібний: `4+1+1`, оптимальний: `3+3`).

---

## Висновки
- Використовуйте **жадібний алгоритм**, якщо:
  - Система монет є канонічною (як стандартна грошова система).
  - Критична швидкодія, і результат гарантовано оптимальний.
- Використовуйте **динамічне програмування**, якщо:
  - Система монет довільна, і жадібний алгоритм може помилитися.
  - Потрібно точно мінімізувати кількість монет.

Підсумок:  
**Жадібний алгоритм швидший, але має обмеження.**  
**ДП повільніший, але завжди правильний.**

# Інтегрування методом Монте-Карло

Цей проєкт демонструє, як наближено обчислювати визначені інтеграли за допомогою **методу Монте-Карло** і порівнювати результат з точним значенням, отриманим через функцію `quad` з SciPy.

---

## Пояснення методу

Мета — оцінити інтеграл

`I = ∫[a,b] f(x) dx`

використовуючи випадкову вибірку.

1. **Генерація випадкових точок**  
   Генеруємо `N` випадкових значень, рівномірно розподілених у межах `[a, b]`.

2. **Обчислення функції**  
   Обчислюємо `f(x)` для кожного випадкового значення.

3. **Обчислення середнього значення**  
   Наближено оцінюємо математичне сподівання функції:  
   mean ≈ (1 / N) · Σ f(xᵢ),  i = 1..N

4. **Масштабування на довжину інтервалу**  
   Множимо середнє на ширину інтервалу:  
   I ≈ (b − a) · mean

5. **Точність**  
   - Зростає зі збільшенням кількості вибірок (`N → ∞`).  
   - Похибка зменшується приблизно як `1 / √N`.

### Результати експерименту

- Функція: `f(x) = x²`, інтервал `[0, 2]`
- Кількість вибірок: `200 000`
- Оцінка Монте-Карло: `2.66645452` зі стандартною похибкою `±0.00533505`
- `scipy.integrate.quad`: `2.66666667` (заявлена похибка `≈2.96e-14`)
- Аналітичне рішення: `2.66666667`
- Абсолютна похибка Монте-Карло: `0.00021214` (≈0.008%) — в межах однієї стандартної похибки, що відповідає очікуваній точності методу.
